{"name":"Code Bleg","tagline":"Wherein I will vomit up some code from time to time.","body":"# A RefluxJS Based Rest Store\n\nKicking over some convention over configuration stuff, I've put together a rest based extension to [RefluxJS](https://github.com/spoike/refluxjs) stores.\n\nThis is how it works:\n\n```coffeescript\n    RefluxRestStore.createCollectionStore \"TestStores.Chaos\",\n      path: \"/api/{kallistiId}/chaos\"\n```\n\nThis will automatically create a store called `TestStores.Chaos.CollectionStore` and the action `TestActions.Chaos.loadCollection`. invoking `loadCollection` will cause the store to trigger with the collection and its sideloaded data. An excerpt from the spex\n```coffeescript\n\n  it \"should listenTo the loadCollection and call it with the correct url\", ->\n    @server.respondWith JSON.stringify(Mocks.CollectionResponse)\n    listener = jasmine.createSpy \"collectionResponse\"\n\n    TestStores.Chaos.CollectionStore.listen listener\n    TestActions.Chaos.loadCollection kallistiId: \"KALLISTI\"\n\n    jasmine.Clock.tick 1\n    @server.respond()\n\n    expect(listener).toHaveBeenCalled()\n    response = listener.mostRecentCall.args[0]\n\n    expect(response.loading).toBeFalsy()\n    expect(response.isError).toBeFalsy()\n    expect(response.newObjects.length).toEqual Mocks.CollectionResponse.chaos.length\n    expect(response.newObjects[0].forum.id).toEqual response.newObjects[0].forum_id\n```\n\nSimilar stuff werks for the `createObjectStore` method. Here's the source\n\n```coffeescript\npkg \"RefluxRestStore\", ->\n  _sideload = (payload, resource) ->\n    _.each resource, (value, attribute) ->\n      if matched = attribute.match(/(.+)_id$/)\n        resource[matched[1]] = _.findWhere payload[matched[1].pluralize()], id: resource[attribute]\n\n  exports =\n    _createStore: (kind, namespace, definition) ->\n      pkg \"#{namespace}.#{kind}Store\", ->\n        actionNamespace           = namespace.replace /Stores/, 'Actions'\n        resourceName              = _.str.underscored _.last(actionNamespace.split(\".\"))\n        actionName                = \"load#{kind}\"\n        actionPackage             = getPkg actionNamespace\n        actionPackage[actionName] = Reflux.createAction actionName\n        action                    = actionPackage[\"load#{kind}\"]\n        init                      = definition.init || (->)\n\n        definition = _.extend definition,\n          init: ->\n            @resourceName = resourceName\n            @listenTo action, @[\"onLoad#{kind}\"].bind(@)\n            init.call this\n\n        Reflux.createStore definition\n\n    createObjectStore: (namespace, definition) ->\n      @_createStore \"Object\", namespace, _.extend definition,\n        onLoadObject: (params) ->\n          params ?= { }\n          url     = pathForPattern @path, params\n          params  = _.omit params, pathKeys(@path)\n          @trigger loading: true\n          promise = $.ajax\n            url: url\n            data: params\n            type: 'GET'\n            dataType: 'json'\n\n          promise.success (payload) =>\n            _sideload payload, payload[@resourceName]\n            @trigger loading: false, object: payload[@resourceName]\n          promise.fail(error) =>\n            @trigger loading: false, isError: true, errors: errors\n\n    createCollectionStore: (namespace, definition) ->\n      @_createStore \"Collection\", namespace, _.extend definition,\n          onLoadCollection: (params) ->\n            params ?= { }\n            url     = pathForPattern @path, params\n            params  = _.omit params, pathKeys(@path)\n\n            @trigger loading: true\n            promise = $.ajax\n              url: url\n              data: params\n              type: 'GET'\n              dataType: 'json'\n\n            promise.success (payload) =>\n              _.each payload[@resourceName], (resource) =>\n                _sideload payload, resource\n              @trigger loading: false, newObjects: payload[@resourceName]\n\n            promise.fail (errors) =>\n              @trigger loading: false, isError: true, errors: errors\n\n```\n\n\n# A simple router for Reflux and ReactJS\n\nSo I've been experimenting with RefluxJS. React is purely a view component and Reflux uses the Flux pattern outlined by Facebook for building React applications. Obviously for a single page site, a router is nice to have. Here's a barebones router that's backed by crossroads.\n\n```coffeescript\npkg \"Router\", ->\n  class Router\n    # TODO: interpolate this\n    pageNamespace: \"Components\"\n    constructor:(options) ->\n      @routes = { }\n      _(options).each (v, k) =>\n        @[k] = v\n\n    reset: ->\n      @routes = { }\n      crossroads.removeAllRoutes()\n\n    draw:(mappingFunction) ->\n      mappingFunction.call @\n\n    resource: (resource, rest...) ->\n      arg2 = rest[0]\n      arg3 = rest[1]\n\n      if _.isFunction arg2\n        childF  = arg2\n        options = { }\n      else if _.isFunction arg3\n        childF  = arg3\n        options = arg2\n      else if _.isObject arg2\n        options = arg2\n      else\n        options = { }\n\n      @routes = _.extend @routes, @_generateRoutes resource, options, childF\n\n    _generateRoutes: (resource, options, childF) ->\n      segments  = _ resource.split \".\"\n      routes    = { }\n      basePath  = options.path ? @_segmentsToPath(segments)\n      basePath  = if @context? then \"#{@context}#{basePath}\" else basePath\n\n      [ \"index\", \"show\", \"edit\" ].forEach (route) =>\n        isIndex        = route == \"index\"\n        token          = if isIndex then resource else \"#{resource}.#{route}\"\n        routeSegments  = segments.concat route\n\n        switch route\n          when \"index\" then pattern = basePath\n          when \"show\"  then pattern = \"#{basePath}/{id}\"\n          when \"edit\"  then pattern = \"#{basePath}/{id}/edit\"\n\n\n        routes[token] =\n          page: @_segmentsToComponent routeSegments\n          path: pattern\n          route: crossroads.addRoute pattern, (args...) ->\n            Actions.Routes.navigate routes[token], args\n\n      if childF\n        childRouter = new Router(context: \"#{basePath}/{#{resource}Id}\", pageNamespace: @pageNamespace)\n        childF.call childRouter\n        _.each childRouter.routes, (value, tok) ->\n          routes[\"#{resource}.#{tok}\"] = value\n\n      routes\n\n    _segmentsToComponent: (segments) ->\n      segments.reduce ((acc, segment) =>\n        acc[_.str.capitalize(segment)]\n      ), window[@pageNamespace]\n\n    _segmentsToPath: (segments) ->\n      dasherized = segments.map (segment) -> _.str.dasherize(segment)\n      \"/#{dasherized.join('/'\n```\n\nThe unit test to explain it:\n\n```coffeescript\ndescribe \"Router\", ->\n  beforeEach ->\n    container = document.createElement 'div'\n    container.setAttribute 'id', 'app-root'\n    document.documentElement.appendChild container\n    @router = new Router(pageNamespace: \"MockComponents\")\n    window.MockComponents =\n      ChaosMachines:\n        Index: \"ChaosMachines.Index\"\n        Show: \"ChaosMachines.Show\"\n        Edit: \"ChaosMachines.Edit\"\n\n      Kallisti:\n        Index: \"Kallisti.Index\"\n        Show: \"Kallisti.Show\"\n\n      Eris:\n        Index: \"Eris.Index\"\n      GoldenApple:\n        Index: \"GoldenApple.Index\"\n\n  afterEach ->\n    container = document.getElementById 'app-root'\n    container.parentNode.removeChild container\n    @router.reset()\n\n  it \"should generate resource routes\", ->\n    @router.draw ->\n      @resource \"chaosMachines\"\n\n    expect(@router.routes[\"chaosMachines\"].page).toEqual MockComponents.ChaosMachines.Index\n    expect(@router.routes[\"chaosMachines.show\"].page).toEqual MockComponents.ChaosMachines.Show\n    expect(@router.routes[\"chaosMachines.edit\"].page).toEqual MockComponents.ChaosMachines.Edit\n    expect(@router.routes[\"chaosMachines\"].path).toEqual \"/chaos-machines\"\n    expect(@router.routes[\"chaosMachines.show\"].path).toEqual \"/chaos-machines/{id}\"\n    expect(@router.routes[\"chaosMachines.edit\"].path).toEqual \"/chaos-machines/{id}/edit\"\n\n  it \"should generate nested routes\", ->\n    @router.draw ->\n      @resource \"chaosMachines\", ->\n        @resource \"kallisti\", ->\n          @resource \"goldenApple\"\n          @resource \"eris\"\n\n    expect(@router.routes[\"chaosMachines.kallisti\"].path).\n      toEqual \"/chaos-machines/{chaosMachinesId}/kallisti\"\n\n    expect(@router.routes[\"chaosMachines.kallisti.goldenApple\"].path).\n      toEqual \"/chaos-machines/{chaosMachinesId}/kallisti/{kallistiId}/golden-apple\"\n\n    expect(@router.routes[\"chaosMachines.kallisti.eris\"].path).\n      toEqual \"/chaos-machines/{chaosMachinesId}/kallisti/{kallistiId}/eris\"\n\n  it \"should take options\", ->\n    @router.draw ->\n      @resource \"chaosMachines\", path: \"/fnord\"\n\n    expect(@router.routes[\"chaosMachines\"].path).toEqual '/fnord'\n    expect(@router.routes[\"chaosMachines.show\"].path).toEqual '/fnord/{id}'\n    expect(@router.routes[\"chaosMachines.edit\"].path).toEqual '/fnord/{id}/edit'\n```\n\nI plan on bundling it into a repo when I get time.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}