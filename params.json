{"name":"Code Bleg","tagline":"Wherein I will vomit up some code from time to time.","body":"# A RefluxJS Based Rest Store\r\n\r\nKicking over some convention over configuration stuff, I've put together a rest based extension to [RefluxJS](https://github.com/spoike/refluxjs) stores.\r\n\r\nThis is how it works:\r\n\r\n```coffeescript\r\n    RefluxRestStore.createCollectionStore \"TestStores.Chaos\",\r\n      path: \"/api/{kallistiId}/chaos\"\r\n```\r\n\r\nThis will automatically create a store called `TestStores.Chaos.CollectionStore` and the action `TestActions.Chaos.loadCollection`. invoking `loadCollection` will cause the store to trigger with the collection and its sideloaded data. An excerpt from the spex\r\n```coffeescript\r\n\r\n  it \"should listenTo the loadCollection and call it with the correct url\", ->\r\n    @server.respondWith JSON.stringify(Mocks.CollectionResponse)\r\n    listener = jasmine.createSpy \"collectionResponse\"\r\n\r\n    TestStores.Chaos.CollectionStore.listen listener\r\n    TestActions.Chaos.loadCollection kallistiId: \"KALLISTI\"\r\n\r\n    jasmine.Clock.tick 1\r\n    @server.respond()\r\n\r\n    expect(listener).toHaveBeenCalled()\r\n    response = listener.mostRecentCall.args[0]\r\n\r\n    expect(response.loading).toBeFalsy()\r\n    expect(response.isError).toBeFalsy()\r\n    expect(response.newObjects.length).toEqual Mocks.CollectionResponse.chaos.length\r\n    expect(response.newObjects[0].forum.id).toEqual response.newObjects[0].forum_id\r\n```\r\n\r\nSimilar stuff werks for the `createObjectStore` method. Here's the source\r\n\r\n```coffeescript\r\npkg \"RefluxRestStore\", ->\r\n  _sideload = (payload, resource) ->\r\n    _.each resource, (value, attribute) ->\r\n      if matched = attribute.match(/(.+)_id$/)\r\n        resource[matched[1]] = _.findWhere payload[matched[1].pluralize()], id: resource[attribute]\r\n\r\n  exports =\r\n    _createStore: (kind, namespace, definition) ->\r\n      pkg \"#{namespace}.#{kind}Store\", ->\r\n        actionNamespace           = namespace.replace /Stores/, 'Actions'\r\n        resourceName              = _.str.underscored _.last(actionNamespace.split(\".\"))\r\n        actionName                = \"load#{kind}\"\r\n        actionPackage             = getPkg actionNamespace\r\n        actionPackage[actionName] = Reflux.createAction actionName\r\n        action                    = actionPackage[\"load#{kind}\"]\r\n        init                      = definition.init || (->)\r\n\r\n        definition = _.extend definition,\r\n          init: ->\r\n            @resourceName = resourceName\r\n            @listenTo action, @[\"onLoad#{kind}\"].bind(@)\r\n            init.call this\r\n\r\n        Reflux.createStore definition\r\n\r\n    createObjectStore: (namespace, definition) ->\r\n      @_createStore \"Object\", namespace, _.extend definition,\r\n        onLoadObject: (params) ->\r\n          params ?= { }\r\n          url     = pathForPattern @path, params\r\n          params  = _.omit params, pathKeys(@path)\r\n          @trigger loading: true\r\n          promise = $.ajax\r\n            url: url\r\n            data: params\r\n            type: 'GET'\r\n            dataType: 'json'\r\n\r\n          promise.success (payload) =>\r\n            _sideload payload, payload[@resourceName]\r\n            @trigger loading: false, object: payload[@resourceName]\r\n          promise.fail(error) =>\r\n            @trigger loading: false, isError: true, errors: errors\r\n\r\n    createCollectionStore: (namespace, definition) ->\r\n      @_createStore \"Collection\", namespace, _.extend definition,\r\n          onLoadCollection: (params) ->\r\n            params ?= { }\r\n            url     = pathForPattern @path, params\r\n            params  = _.omit params, pathKeys(@path)\r\n\r\n            @trigger loading: true\r\n            promise = $.ajax\r\n              url: url\r\n              data: params\r\n              type: 'GET'\r\n              dataType: 'json'\r\n\r\n            promise.success (payload) =>\r\n              _.each payload[@resourceName], (resource) =>\r\n                _sideload payload, resource\r\n              @trigger loading: false, newObjects: payload[@resourceName]\r\n\r\n            promise.fail (errors) =>\r\n              @trigger loading: false, isError: true, errors: errors\r\n\r\n```\r\n\r\n\r\n# A simple router for Reflux and ReactJS\r\n\r\nSo I've been experimenting with RefluxJS. React is purely a view component and Reflux uses the Flux pattern outlined by Facebook for building React applications. Obviously for a single page site, a router is nice to have. Here's a barebones router that's backed by crossroads.\r\n\r\n```coffeescript\r\npkg \"Router\", ->\r\n  class Router\r\n    # TODO: interpolate this\r\n    pageNamespace: \"Components\"\r\n    constructor:(options) ->\r\n      @routes = { }\r\n      _(options).each (v, k) =>\r\n        @[k] = v\r\n\r\n    reset: ->\r\n      @routes = { }\r\n      crossroads.removeAllRoutes()\r\n\r\n    draw:(mappingFunction) ->\r\n      mappingFunction.call @\r\n\r\n    resource: (resource, rest...) ->\r\n      arg2 = rest[0]\r\n      arg3 = rest[1]\r\n\r\n      if _.isFunction arg2\r\n        childF  = arg2\r\n        options = { }\r\n      else if _.isFunction arg3\r\n        childF  = arg3\r\n        options = arg2\r\n      else if _.isObject arg2\r\n        options = arg2\r\n      else\r\n        options = { }\r\n\r\n      @routes = _.extend @routes, @_generateRoutes resource, options, childF\r\n\r\n    _generateRoutes: (resource, options, childF) ->\r\n      segments  = _ resource.split \".\"\r\n      routes    = { }\r\n      basePath  = options.path ? @_segmentsToPath(segments)\r\n      basePath  = if @context? then \"#{@context}#{basePath}\" else basePath\r\n\r\n      [ \"index\", \"show\", \"edit\" ].forEach (route) =>\r\n        isIndex        = route == \"index\"\r\n        token          = if isIndex then resource else \"#{resource}.#{route}\"\r\n        routeSegments  = segments.concat route\r\n\r\n        switch route\r\n          when \"index\" then pattern = basePath\r\n          when \"show\"  then pattern = \"#{basePath}/{id}\"\r\n          when \"edit\"  then pattern = \"#{basePath}/{id}/edit\"\r\n\r\n\r\n        routes[token] =\r\n          page: @_segmentsToComponent routeSegments\r\n          path: pattern\r\n          route: crossroads.addRoute pattern, (args...) ->\r\n            Actions.Routes.navigate routes[token], args\r\n\r\n      if childF\r\n        childRouter = new Router(context: \"#{basePath}/{#{resource}Id}\", pageNamespace: @pageNamespace)\r\n        childF.call childRouter\r\n        _.each childRouter.routes, (value, tok) ->\r\n          routes[\"#{resource}.#{tok}\"] = value\r\n\r\n      routes\r\n\r\n    _segmentsToComponent: (segments) ->\r\n      segments.reduce ((acc, segment) =>\r\n        acc[_.str.capitalize(segment)]\r\n      ), window[@pageNamespace]\r\n\r\n    _segmentsToPath: (segments) ->\r\n      dasherized = segments.map (segment) -> _.str.dasherize(segment)\r\n      \"/#{dasherized.join('/'\r\n```\r\n\r\nThe unit test to explain it:\r\n\r\n```coffeescript\r\ndescribe \"Router\", ->\r\n  beforeEach ->\r\n    container = document.createElement 'div'\r\n    container.setAttribute 'id', 'app-root'\r\n    document.documentElement.appendChild container\r\n    @router = new Router(pageNamespace: \"MockComponents\")\r\n    window.MockComponents =\r\n      ChaosMachines:\r\n        Index: \"ChaosMachines.Index\"\r\n        Show: \"ChaosMachines.Show\"\r\n        Edit: \"ChaosMachines.Edit\"\r\n\r\n      Kallisti:\r\n        Index: \"Kallisti.Index\"\r\n        Show: \"Kallisti.Show\"\r\n\r\n      Eris:\r\n        Index: \"Eris.Index\"\r\n      GoldenApple:\r\n        Index: \"GoldenApple.Index\"\r\n\r\n  afterEach ->\r\n    container = document.getElementById 'app-root'\r\n    container.parentNode.removeChild container\r\n    @router.reset()\r\n\r\n  it \"should generate resource routes\", ->\r\n    @router.draw ->\r\n      @resource \"chaosMachines\"\r\n\r\n    expect(@router.routes[\"chaosMachines\"].page).toEqual MockComponents.ChaosMachines.Index\r\n    expect(@router.routes[\"chaosMachines.show\"].page).toEqual MockComponents.ChaosMachines.Show\r\n    expect(@router.routes[\"chaosMachines.edit\"].page).toEqual MockComponents.ChaosMachines.Edit\r\n    expect(@router.routes[\"chaosMachines\"].path).toEqual \"/chaos-machines\"\r\n    expect(@router.routes[\"chaosMachines.show\"].path).toEqual \"/chaos-machines/{id}\"\r\n    expect(@router.routes[\"chaosMachines.edit\"].path).toEqual \"/chaos-machines/{id}/edit\"\r\n\r\n  it \"should generate nested routes\", ->\r\n    @router.draw ->\r\n      @resource \"chaosMachines\", ->\r\n        @resource \"kallisti\", ->\r\n          @resource \"goldenApple\"\r\n          @resource \"eris\"\r\n\r\n    expect(@router.routes[\"chaosMachines.kallisti\"].path).\r\n      toEqual \"/chaos-machines/{chaosMachinesId}/kallisti\"\r\n\r\n    expect(@router.routes[\"chaosMachines.kallisti.goldenApple\"].path).\r\n      toEqual \"/chaos-machines/{chaosMachinesId}/kallisti/{kallistiId}/golden-apple\"\r\n\r\n    expect(@router.routes[\"chaosMachines.kallisti.eris\"].path).\r\n      toEqual \"/chaos-machines/{chaosMachinesId}/kallisti/{kallistiId}/eris\"\r\n\r\n  it \"should take options\", ->\r\n    @router.draw ->\r\n      @resource \"chaosMachines\", path: \"/fnord\"\r\n\r\n    expect(@router.routes[\"chaosMachines\"].path).toEqual '/fnord'\r\n    expect(@router.routes[\"chaosMachines.show\"].path).toEqual '/fnord/{id}'\r\n    expect(@router.routes[\"chaosMachines.edit\"].path).toEqual '/fnord/{id}/edit'\r\n```\r\n\r\nI plan on bundling it into a repo when I get time.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}