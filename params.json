{"name":"Code Bleg","tagline":"Wherein I will vomit up some code from time to time.","body":"# A simple router for Reflux and ReactJS\r\n\r\nSo I've been experimenting with RefluxJS. React is purely a view component and Reflux uses the Flux pattern outlined by Facebook for building React applications. Obviously for a single page site, a router is nice to have. Here's a barebones router that's backed by crossroads.\r\n\r\n```coffeescript\r\npkg \"Router\", ->\r\n  class Router\r\n    # TODO: interpolate this\r\n    pageNamespace: \"Components\"\r\n    constructor:(options) ->\r\n      @routes = { }\r\n      _(options).each (v, k) =>\r\n        @[k] = v\r\n\r\n    reset: ->\r\n      @routes = { }\r\n      crossroads.removeAllRoutes()\r\n\r\n    draw:(mappingFunction) ->\r\n      mappingFunction.call @\r\n\r\n    resource: (resource, rest...) ->\r\n      arg2 = rest[0]\r\n      arg3 = rest[1]\r\n\r\n      if _.isFunction arg2\r\n        childF  = arg2\r\n        options = { }\r\n      else if _.isFunction arg3\r\n        childF  = arg3\r\n        options = arg2\r\n      else if _.isObject arg2\r\n        options = arg2\r\n      else\r\n        options = { }\r\n\r\n      @routes = _.extend @routes, @_generateRoutes resource, options, childF\r\n\r\n    _generateRoutes: (resource, options, childF) ->\r\n      segments  = _ resource.split \".\"\r\n      routes    = { }\r\n      basePath  = options.path ? @_segmentsToPath(segments)\r\n      basePath  = if @context? then \"#{@context}#{basePath}\" else basePath\r\n\r\n      [ \"index\", \"show\", \"edit\" ].forEach (route) =>\r\n        isIndex        = route == \"index\"\r\n        token          = if isIndex then resource else \"#{resource}.#{route}\"\r\n        routeSegments  = segments.concat route\r\n\r\n        switch route\r\n          when \"index\" then pattern = basePath\r\n          when \"show\"  then pattern = \"#{basePath}/{id}\"\r\n          when \"edit\"  then pattern = \"#{basePath}/{id}/edit\"\r\n\r\n\r\n        routes[token] =\r\n          page: @_segmentsToComponent routeSegments\r\n          path: pattern\r\n          route: crossroads.addRoute pattern, (args...) ->\r\n            Actions.Routes.navigate routes[token], args\r\n\r\n      if childF\r\n        childRouter = new Router(context: \"#{basePath}/{#{resource}Id}\", pageNamespace: @pageNamespace)\r\n        childF.call childRouter\r\n        _.each childRouter.routes, (value, tok) ->\r\n          routes[\"#{resource}.#{tok}\"] = value\r\n\r\n      routes\r\n\r\n    _segmentsToComponent: (segments) ->\r\n      segments.reduce ((acc, segment) =>\r\n        acc[_.str.capitalize(segment)]\r\n      ), window[@pageNamespace]\r\n\r\n    _segmentsToPath: (segments) ->\r\n      dasherized = segments.map (segment) -> _.str.dasherize(segment)\r\n      \"/#{dasherized.join('/'\r\n```\r\n\r\nThe unit test to explain it:\r\n\r\n```coffeescript\r\ndescribe \"Router\", ->\r\n  beforeEach ->\r\n    container = document.createElement 'div'\r\n    container.setAttribute 'id', 'app-root'\r\n    document.documentElement.appendChild container\r\n    @router = new Router(pageNamespace: \"MockComponents\")\r\n    window.MockComponents =\r\n      ChaosMachines:\r\n        Index: \"ChaosMachines.Index\"\r\n        Show: \"ChaosMachines.Show\"\r\n        Edit: \"ChaosMachines.Edit\"\r\n\r\n      Kallisti:\r\n        Index: \"Kallisti.Index\"\r\n        Show: \"Kallisti.Show\"\r\n\r\n      Eris:\r\n        Index: \"Eris.Index\"\r\n      GoldenApple:\r\n        Index: \"GoldenApple.Index\"\r\n\r\n  afterEach ->\r\n    container = document.getElementById 'app-root'\r\n    container.parentNode.removeChild container\r\n    @router.reset()\r\n\r\n  it \"should generate resource routes\", ->\r\n    @router.draw ->\r\n      @resource \"chaosMachines\"\r\n\r\n    expect(@router.routes[\"chaosMachines\"].page).toEqual MockComponents.ChaosMachines.Index\r\n    expect(@router.routes[\"chaosMachines.show\"].page).toEqual MockComponents.ChaosMachines.Show\r\n    expect(@router.routes[\"chaosMachines.edit\"].page).toEqual MockComponents.ChaosMachines.Edit\r\n    expect(@router.routes[\"chaosMachines\"].path).toEqual \"/chaos-machines\"\r\n    expect(@router.routes[\"chaosMachines.show\"].path).toEqual \"/chaos-machines/{id}\"\r\n    expect(@router.routes[\"chaosMachines.edit\"].path).toEqual \"/chaos-machines/{id}/edit\"\r\n\r\n  it \"should generate nested routes\", ->\r\n    @router.draw ->\r\n      @resource \"chaosMachines\", ->\r\n        @resource \"kallisti\", ->\r\n          @resource \"goldenApple\"\r\n          @resource \"eris\"\r\n\r\n    expect(@router.routes[\"chaosMachines.kallisti\"].path).\r\n      toEqual \"/chaos-machines/{chaosMachinesId}/kallisti\"\r\n\r\n    expect(@router.routes[\"chaosMachines.kallisti.goldenApple\"].path).\r\n      toEqual \"/chaos-machines/{chaosMachinesId}/kallisti/{kallistiId}/golden-apple\"\r\n\r\n    expect(@router.routes[\"chaosMachines.kallisti.eris\"].path).\r\n      toEqual \"/chaos-machines/{chaosMachinesId}/kallisti/{kallistiId}/eris\"\r\n\r\n  it \"should take options\", ->\r\n    @router.draw ->\r\n      @resource \"chaosMachines\", path: \"/fnord\"\r\n\r\n    expect(@router.routes[\"chaosMachines\"].path).toEqual '/fnord'\r\n    expect(@router.routes[\"chaosMachines.show\"].path).toEqual '/fnord/{id}'\r\n    expect(@router.routes[\"chaosMachines.edit\"].path).toEqual '/fnord/{id}/edit'\r\n```\r\n\r\nI plan on bundling it into a repo when I get time.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}